# Job Portal Application

This is a comprehensive job portal application featuring a FastAPI backend, MySQL and ChromaDB databases, and a vanilla JavaScript frontend. The application leverages Google's Gemini AI for advanced search capabilities.

## Table of Contents

- [Project Overview](#project-overview)
- [Features](#features)
- [Architecture](#architecture)
- [Folder Structure](#folder-structure)
- [API Endpoints](#api-endpoints)
- [Database Schema](#database-schema)
- [Setup and Installation](#setup-and-installation)
- [Deployment](#deployment)
- [Contributing](#contributing)

## Project Overview

This project aims to provide a robust platform for job seekers to find relevant job openings and for recruiters to post and manage job listings. It uses a hybrid search engine combining traditional keyword-based search with semantic search powered by AI to provide more accurate and relevant results.

## Features

- **Dual User Roles:** Separate interfaces and functionality for Job Seekers and Recruiters.
- **Authentication:** Secure JWT-based authentication for both user types.
- **Job Seeker Dashboard:**
    - Manage profile, skills, and job preferences.
    - Upload and manage resumes.
    - AI-powered job search.
    - Apply for jobs and track applications.
- **Recruiter Dashboard:**
    - Post, manage, and update job vacancies.
    - AI-powered candidate search.
    - Shortlist candidates.
    - Review applications.
- **Hybrid Search Engine:**
    - Natural language query parsing using Google Gemini AI.
    - Traditional SQL-based filtering for structured data.
    - Semantic vector search using ChromaDB for conceptual matching.

## Architecture

The application is built with a clear separation of concerns between the frontend, backend, and data layers.

- **Frontend:** Vanilla HTML, CSS, and JavaScript. No frameworks are used, keeping it lightweight and simple.
- **Backend:** A robust API built with FastAPI (Python).
- **Databases:**
  - **MySQL:** Used for storing structured data like user information, job postings, and applications.
  - **ChromaDB:** A vector database used to store text embeddings for AI-powered semantic search.
- **AI Service:** Google Gemini is used for natural language processing to parse search queries into structured data.

## Folder Structure

```
.
├── backend/         # Backend FastAPI application
│   ├── api/         # API endpoint definitions (main.py)
│   ├── core/        # Core components (config.py, security.py)
│   ├── db/          # Database interaction logic (mysql_db.py, user_queries.py)
│   ├── models/      # Pydantic models for data validation (models.py)
│   └── services/    # Business logic and external services (ai_service.py, vector_service.py)
├── frontend/        # Frontend files
│   ├── css/         # Stylesheets
│   ├── js/          # JavaScript files
│   └── *.html       # HTML files
├── .env.example     # Example environment file
└── README.md        # This file
```

## API Endpoints

The API documentation is automatically generated by FastAPI using OpenAPI.
When the backend server is running, you can access the interactive API documentation at:

- **Swagger UI:** [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)
- **ReDoc:** [http://127.0.0.1:8000/redoc](http://127.0.0.1:8000/redoc)

Key endpoints include:
- `POST /login`: User authentication.
- `POST /register`: New user registration.
- `GET /jobseeker/dashboard`: Get job seeker dashboard data.
- `POST /recruiter/jobs`: Post a new job.
- `POST /search/jobs`: Search for jobs (AI-powered).
- `POST /search/candidates`: Search for candidates (AI-powered).

## Database Schema

The database schema is defined and created in `backend/db/mysql_db.py`. The code in this file is well-documented and serves as the primary source of truth for the database structure.

**Main Tables:**
- `users`: Stores user information for both job seekers and recruiters.
- `jobs`: Stores job postings created by recruiters.
- `applications`: Tracks applications submitted by job seekers for jobs.
- `job_preferences`: Stores job preferences for job seekers.
- `shortlisted_candidates`: Stores candidates shortlisted by recruiters.
- `resume_files`: Manages uploaded resume files.

## Setup and Installation

Follow these steps to set up and run the project locally:

### Prerequisites
- Python 3.8+
- MySQL Server
- An API key for Google Gemini

### 1. Clone the Repository

```bash
git clone https://github.com/your-username/job-portal.git
cd job-portal
```

### 2. Backend Setup

- **Create a virtual environment:**
  ```bash
  python -m venv venv
  source venv/bin/activate  # On Windows, use `venv\Scripts\activate`
  ```

- **Install dependencies:**
  ```bash
  pip install -r backend/requirements.txt
  ```

- **Set up environment variables:**
  - Create a `.env` file in the project root by copying the `.env.example` file.
  - Update the `.env` file with your MySQL database credentials and your Google Gemini API key.

- **Run the backend server:**
  ```bash
  uvicorn backend.api.main:app --reload
  ```
  The backend will be available at `http://127.0.0.1:8000`.

### 3. Frontend Setup

- The frontend is built with vanilla HTML, CSS, and JavaScript, so no special build process is required.
- Simply open the `frontend/index.html` file in your web browser.

## Deployment

Here is a high-level guide for deploying the application:

### Backend (FastAPI)
- **Containerize:** Use Docker to containerize the FastAPI application. A `Dockerfile` will be needed.
- **Database:** Use a managed MySQL database service (e.g., AWS RDS, Google Cloud SQL).
- **Deployment Platform:** Deploy the container to a cloud service like:
  - AWS Elastic Beanstalk
  - Google App Engine
  - Heroku
- **CI/CD:** Set up a CI/CD pipeline (e.g., using GitHub Actions) to automate testing and deployment.

### Frontend (Static Files)
- The `frontend` directory contains static files that can be hosted on any static site hosting service, such as:
  - Netlify
  - Vercel
  - AWS S3 with CloudFront
  - GitHub Pages

## Contributing

Contributions are welcome! Please follow these steps:

1. Fork the repository.
2. Create a new branch (`git checkout -b feature/your-feature`).
3. Make your changes.
4. Commit your changes (`git commit -m 'Add some feature'`).
5. Push to the branch (`git push origin feature/your-feature`).
6. Open a pull request.